---
name: Weekly Audit of Permanent Resources

on:
    schedule:
        # Every Sunday at 22:00 UTC
        - cron: 0 22 * * 0
    workflow_dispatch:
        inputs:
            provider:
                description: Cloud provider to audit
                type: choice
                options:
                    - all
                    - aws
                    - azure
                default: all
    pull_request:
        paths:
            - .github/workflows/permanent_resources_audit.yml
            - .github/config/permanent_resources_allowlist.yml

env:
    AWS_PROFILE: infraex
    # renovate: datasource=github-tags depName=gruntwork-io/cloud-nuke
    CLOUD_NUKE_VERSION: v0.46.0
    # Slack channel for internal notifications (FYI)
    SLACK_CHANNEL_ID: C076N4G1162
    # Slack channel for PR tests
    SLACK_CHANNEL_ID_PR: C07E4FF6YMB

    PROVIDER: ${{ github.event.inputs.provider || 'all' }}

    # Regions excluded from permanent audit as they are cleaned daily or weekly (see README.md)
    AWS_EXCLUDED_REGIONS: '["eu-west-2", "eu-west-3", "eu-north-1", "us-east-1", "us-east-2"]'
    AZURE_EXCLUDED_REGIONS: '["swedencentral", "spaincentral"]'

# Limit workflow to a single execution per ref
concurrency:
    group: ${{ github.workflow }}-${{ github.ref }}
    cancel-in-progress: true

jobs:
    triage:
        runs-on: ubuntu-latest
        outputs:
            run_aws: ${{ github.event.inputs.provider == 'all' || github.event.inputs.provider == 'aws' || github.event.inputs.provider == null }}
            run_azure: ${{ github.event.inputs.provider == 'all' || github.event.inputs.provider == 'azure' || github.event.inputs.provider == null }}
        steps:
            - run: echo "Triage complete - AWS:${{ github.event.inputs.provider != 'azure' }} Azure:${{ github.event.inputs.provider != 'aws' }}"

    aws-list-regions:
        runs-on: ubuntu-latest
        needs: triage
        if: needs.triage.outputs.run_aws == 'true'
        outputs:
            regions: ${{ steps.get-regions.outputs.regions }}
        steps:
            - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6

            - name: Import Secrets
              id: secrets
              uses: hashicorp/vault-action@4c06c5ccf5c0761b6029f56cfb1dcf5565918a3b # v3
              with:
                  url: ${{ secrets.VAULT_ADDR }}
                  method: approle
                  roleId: ${{ secrets.VAULT_ROLE_ID }}
                  secretId: ${{ secrets.VAULT_SECRET_ID }}
                  exportEnv: false
                  secrets: |
                      secret/data/products/infrastructure-experience/ci/common AWS_ACCESS_KEY;
                      secret/data/products/infrastructure-experience/ci/common AWS_SECRET_KEY;

            - name: Configure AWS CLI
              uses: camunda/camunda-deployment-references/./.github/actions/aws-configure-cli@3dcad0fc66fa0f8bc85efb7870030f86608d0111 # main
              with:
                  vault-addr: ${{ secrets.VAULT_ADDR }}
                  vault-role-id: ${{ secrets.VAULT_ROLE_ID }}
                  vault-secret-id: ${{ secrets.VAULT_SECRET_ID }}
                  aws-profile: ${{ env.AWS_PROFILE }}
                  aws-region: eu-central-1

            - name: Get all AWS regions
              id: get-regions
              run: |
                  # Get all enabled AWS regions for the account, excluding daily/weekly regions
                  REGIONS=$(aws ec2 describe-regions --query "Regions[].RegionName" --output json | jq -c --argjson excluded '${{ env.AWS_EXCLUDED_REGIONS }}' '[.[] | select(. as $r | $excluded | index($r) | not)]')
                  echo "regions=$REGIONS" >> "$GITHUB_OUTPUT"
                  echo "Found $(echo "$REGIONS" | jq 'length') AWS regions (excluded daily/weekly: ${{ env.AWS_EXCLUDED_REGIONS }})"

    aws-permanent-audit:
        runs-on: ubuntu-latest
        needs: aws-list-regions
        if: needs.aws-list-regions.outputs.regions != ''
        strategy:
            fail-fast: false
            matrix:
                region: ${{ fromJson(needs.aws-list-regions.outputs.regions) }}

        steps:
            - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6

            - name: Install asdf tools
              uses: camunda/infraex-common-config/./.github/actions/asdf-install-tooling@193a21e1e56c9a65517a822224ac3b4ffa4d6ae4 # 1.5.9

            - name: Import Secrets
              id: secrets
              uses: hashicorp/vault-action@4c06c5ccf5c0761b6029f56cfb1dcf5565918a3b # v3
              with:
                  url: ${{ secrets.VAULT_ADDR }}
                  method: approle
                  roleId: ${{ secrets.VAULT_ROLE_ID }}
                  secretId: ${{ secrets.VAULT_SECRET_ID }}
                  exportEnv: false
                  secrets: |
                      secret/data/products/infrastructure-experience/ci/common AWS_ACCESS_KEY;
                      secret/data/products/infrastructure-experience/ci/common AWS_SECRET_KEY;
                      secret/data/products/infrastructure-experience/ci/common SLACK_BOT_TOKEN;

            - name: Configure AWS CLI
              uses: camunda/camunda-deployment-references/./.github/actions/aws-configure-cli@3dcad0fc66fa0f8bc85efb7870030f86608d0111 # main
              with:
                  vault-addr: ${{ secrets.VAULT_ADDR }}
                  vault-role-id: ${{ secrets.VAULT_ROLE_ID }}
                  vault-secret-id: ${{ secrets.VAULT_SECRET_ID }}
                  aws-profile: ${{ env.AWS_PROFILE }}
                  aws-region: ${{ matrix.region }}

            - name: Install Cloud Nuke
              run: |
                  curl -LO \
                    --retry 5 \
                    --max-time 15 \
                    --retry-delay 30 \
                    https://github.com/gruntwork-io/cloud-nuke/releases/download/${{ env.CLOUD_NUKE_VERSION }}/cloud-nuke_linux_amd64
                  chmod +x cloud-nuke_linux_amd64

            - name: Load allowlist for region
              id: allowlist
              run: |
                  ALLOWLIST_FILE=".github/config/permanent_resources_allowlist.yml"
                  REGION="${{ matrix.region }}"

                  # Check if region has allowlist configuration
                  HAS_ALLOWLIST=$(yq -r ".aws.\"$REGION\" // \"null\"" "$ALLOWLIST_FILE")

                  if [[ "$HAS_ALLOWLIST" == "null" ]]; then
                      echo "Region $REGION is not in allowlist - any resources found are unexpected"
                      touch allowlist_patterns.txt
                  else
                      # Extract allowlisted patterns for this region with resource type prefix
                      echo "Loading allowlist for AWS region: $REGION"

                      # Create patterns file: "resource_type pattern" format to match against extracted resources
                      # Output format: "s3 bucket-name" or "cloudformation-stack StackSet-Wiz-*"
                      yq -r ".aws.\"$REGION\" | to_entries | .[] | .key as \$type | .value[]? | \"\(\$type) \(.)\"" "$ALLOWLIST_FILE" 2>/dev/null | grep -v ' $' | sort -u > allowlist_patterns.txt || touch allowlist_patterns.txt

                      echo "Allowlist patterns loaded:"
                      cat allowlist_patterns.txt
                  fi

            - name: Run Cloud Nuke in Dry-Run mode
              id: cloud-nuke-audit
              timeout-minutes: 60
              env:
                  DISABLE_TELEMETRY: 'true'
              run: |
                  REGION="${{ matrix.region }}"
                  {
                      echo "## AWS Permanent Resources Audit - $REGION"
                      echo "Date: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
                      echo ""
                  } > audit_report.txt

                  # Run cloud-nuke in dry-run mode and capture output
                  ./cloud-nuke_linux_amd64 aws --dry-run \
                    --region $REGION \
                    --force \
                    --older-than 0h \
                    --exclude-resource-type ec2_dhcp_option \
                    --exclude-resource-type cloudtrail 2>&1 | tee cloud_nuke_output.txt || true

                  # Identify default VPC and its associated resources to filter them out
                  DEFAULT_VPC_ID=$(aws ec2 describe-vpcs \
                    --region "$REGION" \
                    --filters "Name=isDefault,Values=true" \
                    --query "Vpcs[0].VpcId" --output text 2>/dev/null || echo "None")
                  echo "Default VPC in $REGION: $DEFAULT_VPC_ID"

                  # Build list of default VPC resource IDs to ignore
                  true > default_vpc_resources.txt
                  if [[ "$DEFAULT_VPC_ID" != "None" && "$DEFAULT_VPC_ID" != "null" ]]; then
                      echo "$DEFAULT_VPC_ID" >> default_vpc_resources.txt
                      # Default subnets
                      aws ec2 describe-subnets --region "$REGION" \
                        --filters "Name=vpc-id,Values=$DEFAULT_VPC_ID" "Name=defaultForAz,Values=true" \
                        --query "Subnets[].SubnetId" --output text 2>/dev/null | tr '\t' '\n' >> default_vpc_resources.txt || true
                      # Default IGW
                      aws ec2 describe-internet-gateways --region "$REGION" \
                        --filters "Name=attachment.vpc-id,Values=$DEFAULT_VPC_ID" \
                        --query "InternetGateways[].InternetGatewayId" --output text 2>/dev/null | tr '\t' '\n' >> default_vpc_resources.txt || true
                      # Default security group
                      aws ec2 describe-security-groups --region "$REGION" \
                        --filters "Name=vpc-id,Values=$DEFAULT_VPC_ID" "Name=group-name,Values=default" \
                        --query "SecurityGroups[].GroupId" --output text 2>/dev/null | tr '\t' '\n' >> default_vpc_resources.txt || true
                      echo "Default VPC resources to ignore:"
                      cat default_vpc_resources.txt
                  fi

                  # Filter out allowlisted resources
                  echo "### Allowlisted resources (approved):" >> audit_report.txt
                  ALLOWLISTED_COUNT=0
                  UNALLOWLISTED_COUNT=0

                  # Initialize output files
                  true > unallowlisted_resources.txt
                  true > allowlisted_resources.txt

                  # Extract resource lines from cloud-nuke table output
                  # The table format has: | resource_type | region | identifier | nukable |
                  # We need to strip ANSI codes and extract lines starting with | that contain resource data
                  # Also filter out cloud-nuke log lines like [Query], [Target], [Exclude], [List]
                  sed 's/\x1b\[[0-9;]*m//g' cloud_nuke_output.txt | grep '^|' | grep -v -- '---' | grep -v 'Resource Type' | while IFS= read -r line; do
                      # Extract resource type and identifier from the table line
                      resource_info=$(echo "$line" | tr -d '|' | tr -s ' ' | sed 's/^ //;s/ $//')
                      # Skip cloud-nuke log/info lines (e.g. [Query], [Target], [Exclude], [List])
                      first_field=$(echo "$resource_info" | awk '{print $1}')
                      [[ "$first_field" == \[* ]] && continue
                      echo "$resource_info"
                  done > extracted_resources.txt

                  # Debug: show extracted resources count
                  echo "DEBUG: Extracted $(wc -l < extracted_resources.txt) resources"
                  head -5 extracted_resources.txt || true

                  while IFS= read -r line; do
                      [[ -z "$line" ]] && continue
                      # Extract type and name from the resource line (format: "type region name")
                      res_type=$(echo "$line" | awk '{print $1}')
                      res_name=$(echo "$line" | awk '{print $3}')

                      # Skip cloud-nuke log/info lines (e.g. [Query], [Target], [Exclude], [List])
                      if [[ "$res_type" == \[* ]]; then
                          echo "Skipping cloud-nuke log line: $line"
                          continue
                      fi

                      # Skip default VPC resources (identified by their IDs)
                      if grep -qxF "$res_name" default_vpc_resources.txt 2>/dev/null; then
                          echo "Skipping default VPC resource: $res_type $res_name"
                          echo "$line" >> allowlisted_resources.txt
                          ((ALLOWLISTED_COUNT++)) || true
                          continue
                      fi

                      is_allowlisted=false
                      while IFS= read -r pattern; do
                          # Skip empty patterns
                          [[ -z "$pattern" ]] && continue
                          # Pattern format: "type pattern_value"
                          pattern_type=$(echo "$pattern" | awk '{print $1}')
                          pattern_value=$(echo "$pattern" | awk '{print $2}')

                          # Check if resource type matches pattern type
                          if [[ "$res_type" == "$pattern_type" ]]; then
                              # Convert glob pattern to regex and check against resource name
                              regex_pattern=${pattern_value//\*/.*}
                              if echo "$res_name" | grep -qE "^${regex_pattern}$"; then
                                  is_allowlisted=true
                                  break
                              fi
                          fi
                      done < allowlist_patterns.txt

                      if $is_allowlisted; then
                          echo "$line" >> allowlisted_resources.txt
                          ((ALLOWLISTED_COUNT++)) || true
                      else
                          echo "$line" >> unallowlisted_resources.txt
                          ((UNALLOWLISTED_COUNT++)) || true
                      fi
                  done < extracted_resources.txt

                  # Ignore a single guardduty detector per region (AWS enables one by default)
                  GUARDDUTY_COUNT=$(grep -c '^guardduty ' unallowlisted_resources.txt 2>/dev/null || echo 0)
                  if [[ "$GUARDDUTY_COUNT" -eq 1 ]]; then
                      echo "Ignoring single default GuardDuty detector"
                      grep '^guardduty ' unallowlisted_resources.txt >> allowlisted_resources.txt
                      grep -v '^guardduty ' unallowlisted_resources.txt > unallowlisted_resources.tmp && mv unallowlisted_resources.tmp unallowlisted_resources.txt
                      ((ALLOWLISTED_COUNT++)) || true
                      ((UNALLOWLISTED_COUNT--)) || true
                  fi

                  {
                      head -50 allowlisted_resources.txt || echo "None"
                      echo ""
                      echo "Total allowlisted: $ALLOWLISTED_COUNT"
                      echo ""
                      echo "### ‚ö†Ô∏è Non-allowlisted resources (review required):"
                      head -100 unallowlisted_resources.txt || echo "None"
                      echo ""
                      echo "Total non-allowlisted: $UNALLOWLISTED_COUNT"
                  } >> audit_report.txt

                  cat audit_report.txt

                  # Save counts for Slack message
                  echo "UNALLOWLISTED_COUNT=$UNALLOWLISTED_COUNT" >> "$GITHUB_OUTPUT"
                  echo "TOTAL_RESOURCES=$((ALLOWLISTED_COUNT + UNALLOWLISTED_COUNT))" >> "$GITHUB_OUTPUT"

            - name: Determine Slack channel
              id: slack-channel
              run: |
                  if [[ "${{ github.event_name }}" == "pull_request" ]]; then
                    echo "channel=${{ env.SLACK_CHANNEL_ID_PR }}" >> "$GITHUB_OUTPUT"
                  else
                    echo "channel=${{ env.SLACK_CHANNEL_ID }}" >> "$GITHUB_OUTPUT"
                  fi

            - name: Prepare Slack message
              id: slack-message
              run: |
                  UNALLOWLISTED="${{ steps.cloud-nuke-audit.outputs.UNALLOWLISTED_COUNT }}"
                  TOTAL="${{ steps.cloud-nuke-audit.outputs.TOTAL_RESOURCES }}"
                  RUN_DATE=$(date -u '+%Y-%m-%d %H:%M UTC')
                  # Slack block text limit is 3000 chars, limit to 20 resources
                  MAX_DISPLAY=20

                  echo "run_date=$RUN_DATE" >> "$GITHUB_OUTPUT"

                  if [[ "$UNALLOWLISTED" -gt 0 ]]; then
                    echo "status_emoji=‚ö†Ô∏è" >> "$GITHUB_OUTPUT"
                    # Build resource list as single line with literal \n for Slack mrkdwn
                    RESOURCE_LIST=$(head -$MAX_DISPLAY unallowlisted_resources.txt | awk '{type=$1; region=$2; name=$3; line="[" type "] " name " (" region ")"; if (NR>1) printf "\\n"; printf "%s", line}')

                    if [[ "$UNALLOWLISTED" -gt $MAX_DISPLAY ]]; then
                      RESOURCE_LIST="${RESOURCE_LIST}... and $((UNALLOWLISTED - MAX_DISPLAY)) more (see full report)"
                    fi

                    # Use printf %s to output literal string without interpreting escapes
                    printf '%s\n' "status_text=*‚ö†Ô∏è Non-allowlisted resources ($UNALLOWLISTED):*\n\`\`\`\n${RESOURCE_LIST}\n\`\`\`" >> "$GITHUB_OUTPUT"
                  else
                    echo "status_emoji=‚úÖ" >> "$GITHUB_OUTPUT"
                    echo "status_text=*‚úÖ All $TOTAL resources are allowlisted*" >> "$GITHUB_OUTPUT"
                  fi

            - name: Post Audit Report to Slack
              if: steps.cloud-nuke-audit.outputs.UNALLOWLISTED_COUNT > 0
              uses: slackapi/slack-github-action@91efab103c0de0a537f72a35f6b8cda0ee76bf0a # v2.1.1
              with:
                  method: chat.postMessage
                  token: ${{ steps.secrets.outputs.SLACK_BOT_TOKEN }}
                  payload: |
                      {
                        "channel": "${{ steps.slack-channel.outputs.channel }}",
                        "unfurl_links": false,
                        "unfurl_media": false,
                        "text": "üìã Weekly AWS Permanent Resources Audit - ${{ matrix.region }}",
                        "blocks": [
                          {
                            "type": "header",
                            "text": {
                              "type": "plain_text",
                              "text": "üìã Weekly AWS Permanent Resources Audit",
                              "emoji": true
                            }
                          },
                          {
                            "type": "section",
                            "fields": [
                              {
                                "type": "mrkdwn",
                                "text": "*Region:*\n${{ matrix.region }}"
                              },
                              {
                                "type": "mrkdwn",
                                "text": "*Use Case:*\nPermanent resources audit"
                              }
                            ]
                          },
                          {
                            "type": "section",
                            "text": {
                              "type": "mrkdwn",
                              "text": "${{ steps.slack-message.outputs.status_text }}"
                            }
                          },
                          {
                            "type": "section",
                            "text": {
                              "type": "mrkdwn",
                              "text": "<!subteam^S06NTRBMWUD> please either:\n‚Ä¢ Update the <${{ github.server_url }}/${{ github.repository }}/blob/${{ github.ref_name }}/.github/config/permanent_resources_allowlist.yml|allowlist configuration> if these resources are approved\n‚Ä¢ Or investigate the origin of these unexpected permanent resources"
                            }
                          },
                          {
                            "type": "section",
                            "text": {
                              "type": "mrkdwn",
                              "text": "‚ÑπÔ∏è This is a *dry-run* audit of permanent resources. No resources were deleted.\n\n<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View full audit report>"
                            }
                          },
                          {
                            "type": "context",
                            "elements": [
                              {
                                "type": "mrkdwn",
                                "text": "Run date: ${{ steps.slack-message.outputs.run_date }}"
                              }
                            ]
                          }
                        ]
                      }

    azure-list-regions:
        runs-on: ubuntu-latest
        needs: triage
        if: needs.triage.outputs.run_azure == 'true'
        permissions:
            id-token: write
        outputs:
            regions: ${{ steps.get-regions.outputs.regions }}
        steps:
            - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6

            - name: Import Secrets
              id: secrets
              uses: hashicorp/vault-action@4c06c5ccf5c0761b6029f56cfb1dcf5565918a3b # v3
              with:
                  url: ${{ secrets.VAULT_ADDR }}
                  method: approle
                  roleId: ${{ secrets.VAULT_ROLE_ID }}
                  secretId: ${{ secrets.VAULT_SECRET_ID }}
                  exportEnv: true
                  secrets: |
                      secret/data/products/infrastructure-experience/ci/common AZURE_CLIENT_ID;
                      secret/data/products/infrastructure-experience/ci/common AZURE_TENANT_ID;
                      secret/data/products/infrastructure-experience/ci/common AZURE_SUBSCRIPTION_ID;

            - name: Azure Login with OIDC
              uses: azure/login@a457da9ea143d694b1b9c7c869ebb04ebe844ef5 # v2.3.0
              with:
                  client-id: ${{ steps.secrets.outputs.AZURE_CLIENT_ID }}
                  tenant-id: ${{ steps.secrets.outputs.AZURE_TENANT_ID }}
                  subscription-id: ${{ steps.secrets.outputs.AZURE_SUBSCRIPTION_ID }}

            - name: Get all Azure regions
              id: get-regions
              run: |
                  # Get all physical regions available for the subscription, excluding daily/weekly regions
                  REGIONS=$(az account list-locations --query "[?metadata.regionType=='Physical'].name" -o json | jq -c --argjson excluded '${{ env.AZURE_EXCLUDED_REGIONS }}' '[.[] | select(. as $r | $excluded | index($r) | not)]')
                  echo "regions=$REGIONS" >> "$GITHUB_OUTPUT"
                  echo "Found $(echo "$REGIONS" | jq 'length') Azure regions (excluded daily/weekly: ${{ env.AZURE_EXCLUDED_REGIONS }})"

    azure-permanent-audit:
        runs-on: ubuntu-latest
        needs: azure-list-regions
        if: needs.azure-list-regions.outputs.regions != ''
        permissions:
            id-token: write
        strategy:
            fail-fast: false
            matrix:
                region: ${{ fromJson(needs.azure-list-regions.outputs.regions) }}

        steps:
            - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6

            - name: Install asdf tools
              uses: camunda/infraex-common-config/./.github/actions/asdf-install-tooling@193a21e1e56c9a65517a822224ac3b4ffa4d6ae4 # 1.5.9

            - name: Import Secrets
              id: secrets
              uses: hashicorp/vault-action@4c06c5ccf5c0761b6029f56cfb1dcf5565918a3b # v3
              with:
                  url: ${{ secrets.VAULT_ADDR }}
                  method: approle
                  roleId: ${{ secrets.VAULT_ROLE_ID }}
                  secretId: ${{ secrets.VAULT_SECRET_ID }}
                  exportEnv: true
                  secrets: |
                      secret/data/products/infrastructure-experience/ci/common AZURE_CLIENT_ID;
                      secret/data/products/infrastructure-experience/ci/common AZURE_TENANT_ID;
                      secret/data/products/infrastructure-experience/ci/common AZURE_SUBSCRIPTION_ID;
                      secret/data/products/infrastructure-experience/ci/common SLACK_BOT_TOKEN;

            - name: Azure Login with OIDC
              uses: azure/login@a457da9ea143d694b1b9c7c869ebb04ebe844ef5 # v2.3.0
              with:
                  client-id: ${{ steps.secrets.outputs.AZURE_CLIENT_ID }}
                  tenant-id: ${{ steps.secrets.outputs.AZURE_TENANT_ID }}
                  subscription-id: ${{ steps.secrets.outputs.AZURE_SUBSCRIPTION_ID }}

            - name: Audit Azure Permanent Resources
              id: azure-audit
              env:
                  AZURE_REGION: ${{ matrix.region }}
              run: |
                  ALLOWLIST_FILE=".github/config/permanent_resources_allowlist.yml"
                  REGION="${{ matrix.region }}"

                  {
                      echo "## Azure Permanent Resources Audit - $REGION"
                      echo "Date: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
                      echo ""
                  } > audit_report.txt

                  # Check if region has allowlist configuration
                  HAS_ALLOWLIST=$(yq -r ".azure.\"$REGION\" // \"null\"" "$ALLOWLIST_FILE")

                  if [[ "$HAS_ALLOWLIST" == "null" ]]; then
                      echo "Region $REGION is not in allowlist - any resources found are unexpected"
                      touch allowlisted_rgs.txt
                  else
                      # Load allowlisted resource groups for this region
                      yq -r ".azure.\"$REGION\".resource_groups[]?" "$ALLOWLIST_FILE" 2>/dev/null > allowlisted_rgs.txt || touch allowlisted_rgs.txt
                      echo "Allowlisted resource groups for $REGION:"
                      cat allowlisted_rgs.txt
                  fi

                  {
                      echo "### Resource Groups in $REGION:"
                      echo ""
                  } >> audit_report.txt

                  # List all resource groups in this region
                  az group list --query "[?location=='$REGION']" -o json > all_rgs.json

                  TOTAL_RGS=$(jq 'length' all_rgs.json)
                  echo "Found $TOTAL_RGS resource groups in $REGION"

                  # If no resources in this region, skip further processing
                  if [[ "$TOTAL_RGS" -eq 0 ]]; then
                      echo "‚úÖ No resource groups found in $REGION" >> audit_report.txt
                      cat audit_report.txt
                      {
                          echo "ALLOWLISTED_RG_COUNT=0"
                          echo "UNALLOWLISTED_RG_COUNT=0"
                          echo "TOTAL_RG_COUNT=0"
                      } >> "$GITHUB_OUTPUT"
                      exit 0
                  fi

                  echo "#### ‚úÖ Allowlisted Resource Groups:" >> audit_report.txt
                  ALLOWLISTED_RG_COUNT=0
                  UNALLOWLISTED_RG_COUNT=0

                  while IFS= read -r rg_name; do
                      is_allowlisted=false
                      while IFS= read -r pattern; do
                          [[ -z "$pattern" ]] && continue
                          regex_pattern=${pattern//\*/.*}
                          if echo "$rg_name" | grep -qE "^${regex_pattern}$"; then
                              is_allowlisted=true
                              break
                          fi
                      done < allowlisted_rgs.txt

                      if $is_allowlisted; then
                          echo "  - $rg_name" >> audit_report.txt
                          ((ALLOWLISTED_RG_COUNT++)) || true
                      else
                          echo "$rg_name" >> unallowlisted_rgs.txt
                          ((UNALLOWLISTED_RG_COUNT++)) || true
                      fi
                  done < <(jq -r '.[].name' all_rgs.json)

                  {
                      echo "Total: $ALLOWLISTED_RG_COUNT"
                      echo ""
                      echo "#### ‚ö†Ô∏è Non-allowlisted Resource Groups (review required):"
                      if [[ -s unallowlisted_rgs.txt ]]; then
                          while IFS= read -r rg; do
                              echo "  - $rg"
                          done < unallowlisted_rgs.txt
                      else
                          echo "  None"
                      fi
                      echo "Total: $UNALLOWLISTED_RG_COUNT"
                      echo ""
                      echo "### Resources by type:"
                  } >> audit_report.txt

                  # Get a summary of resources by type
                  az resource list --query "[?location=='$REGION'] | [].type" -o json | jq -r 'group_by(.) | map({type: .[0], count: length}) | sort_by(-.count) | .[] | "\(.type): \(.count)"' >> audit_report.txt || echo "Unable to list resources" >> audit_report.txt

                  cat audit_report.txt

                  # Save counts for Slack
                  {
                      echo "ALLOWLISTED_RG_COUNT=$ALLOWLISTED_RG_COUNT"
                      echo "UNALLOWLISTED_RG_COUNT=$UNALLOWLISTED_RG_COUNT"
                      echo "TOTAL_RG_COUNT=$((ALLOWLISTED_RG_COUNT + UNALLOWLISTED_RG_COUNT))"
                  } >> "$GITHUB_OUTPUT"

            - name: Determine Slack channel
              id: slack-channel
              run: |
                  if [[ "${{ github.event_name }}" == "pull_request" ]]; then
                    echo "channel=${{ env.SLACK_CHANNEL_ID_PR }}" >> "$GITHUB_OUTPUT"
                  else
                    echo "channel=${{ env.SLACK_CHANNEL_ID }}" >> "$GITHUB_OUTPUT"
                  fi

            - name: Prepare Slack message
              id: slack-message
              run: |
                  UNALLOWLISTED="${{ steps.azure-audit.outputs.UNALLOWLISTED_RG_COUNT }}"
                  TOTAL="${{ steps.azure-audit.outputs.TOTAL_RG_COUNT }}"
                  RUN_DATE=$(date -u '+%Y-%m-%d %H:%M UTC')
                  # Slack block text limit is 3000 chars, limit to 20 items
                  MAX_DISPLAY=20

                  echo "run_date=$RUN_DATE" >> "$GITHUB_OUTPUT"

                  if [[ "$UNALLOWLISTED" -gt 0 ]]; then
                    # Build resource group list as single line with literal \n for Slack mrkdwn
                    RG_LIST=$(head -$MAX_DISPLAY unallowlisted_rgs.txt | awk '{if (NR>1) printf "\\n"; printf "%s", $0}')

                    if [[ "$UNALLOWLISTED" -gt $MAX_DISPLAY ]]; then
                      RG_LIST="${RG_LIST}... and $((UNALLOWLISTED - MAX_DISPLAY)) more (see full report)"
                    fi

                    # Use printf %s to output literal string without interpreting escapes
                    printf '%s\n' "status_text=*‚ö†Ô∏è Non-allowlisted Resource Groups ($UNALLOWLISTED):*\n\`\`\`\n${RG_LIST}\n\`\`\`" >> "$GITHUB_OUTPUT"
                  else
                    echo "status_text=*‚úÖ All $TOTAL Resource Groups are allowlisted*" >> "$GITHUB_OUTPUT"
                  fi

            - name: Post Azure Audit Report to Slack
              if: steps.azure-audit.outputs.UNALLOWLISTED_RG_COUNT > 0
              uses: slackapi/slack-github-action@91efab103c0de0a537f72a35f6b8cda0ee76bf0a # v2.1.1
              with:
                  method: chat.postMessage
                  token: ${{ steps.secrets.outputs.SLACK_BOT_TOKEN }}
                  payload: |
                      {
                        "channel": "${{ steps.slack-channel.outputs.channel }}",
                        "unfurl_links": false,
                        "unfurl_media": false,
                        "text": "üìã Weekly Azure Permanent Resources Audit - ${{ matrix.region }}",
                        "blocks": [
                          {
                            "type": "header",
                            "text": {
                              "type": "plain_text",
                              "text": "üìã Weekly Azure Permanent Resources Audit",
                              "emoji": true
                            }
                          },
                          {
                            "type": "section",
                            "fields": [
                              {
                                "type": "mrkdwn",
                                "text": "*Region:*\n${{ matrix.region }}"
                              },
                              {
                                "type": "mrkdwn",
                                "text": "*Use Case:*\nPermanent resources audit"
                              }
                            ]
                          },
                          {
                            "type": "section",
                            "text": {
                              "type": "mrkdwn",
                              "text": "${{ steps.slack-message.outputs.status_text }}"
                            }
                          },
                          {
                            "type": "section",
                            "text": {
                              "type": "mrkdwn",
                              "text": "<!subteam^S06NTRBMWUD> please either:\n‚Ä¢ Update the <${{ github.server_url }}/${{ github.repository }}/blob/${{ github.ref_name }}/.github/config/permanent_resources_allowlist.yml|allowlist configuration> if these resources are approved\n‚Ä¢ Or investigate the origin of these unexpected permanent resources"
                            }
                          },
                          {
                            "type": "section",
                            "text": {
                              "type": "mrkdwn",
                              "text": "‚ÑπÔ∏è This is an audit of permanent resources in Azure. No resources were deleted.\n\n<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View full audit report>"
                            }
                          },
                          {
                            "type": "context",
                            "elements": [
                              {
                                "type": "mrkdwn",
                                "text": "Run date: ${{ steps.slack-message.outputs.run_date }}"
                              }
                            ]
                          }
                        ]
                      }

    notify-on-failure:
        runs-on: ubuntu-latest
        if: failure()
        needs:
            - aws-list-regions
            - aws-permanent-audit
            - azure-list-regions
            - azure-permanent-audit
        steps:
            - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6

            - name: Notify in Slack in case of failure
              id: slack-notification
              if: github.event_name == 'schedule'
              uses: ./.github/actions/report-failure-on-slack
              with:
                  vault_addr: ${{ secrets.VAULT_ADDR }}
                  vault_role_id: ${{ secrets.VAULT_ROLE_ID }}
                  vault_secret_id: ${{ secrets.VAULT_SECRET_ID }}
